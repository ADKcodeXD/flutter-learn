# flutter 入门

## first app

创建一个的组件

```dart
void main(List<String> args) {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    final wordPair = WordPair.random();
    return MaterialApp(
      title: 'Welcome to Flutter',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('这是我的第一个页面'),
        ),
        body:const Center(
          child: RandomWords(),
        ),
      ),
    );
  }
}
```

widget 是一个组件类，用于构建ui和页面。

## flutter 状态组件

```dart
class RandomWords extends StatefulWidget {
  const RandomWords({ Key? key }) : super(key: key);
  @override
  State<RandomWords> createState() => _RandomWordsState();
}

class _RandomWordsState extends State<RandomWords> {
  @override
  Widget build(BuildContext context) {
    final wordPair = WordPair.random();
    return Text(wordPair.asPascalCase);
  }
}
```

可以通过继承state来创建一个状态组件

同时可以在extends StatefulWidget的情况下：生成一个state

## Create an infinite scrolling ListView

创建无限列表：

1 声明一个字体样式和一个数组 在state私有类里面

```dart
final _suggestions = <WordPair>[];
final _biggerFont = const TextStyle(fontSize: 18);
```

返回一个listView的builder

```dart
@override
Widget build(BuildContext context) {
    return ListView.builder(
        padding: const EdgeInsets.all(16.0),
        itemBuilder: /*1*/ (context, i) {
            if (i.isOdd) return const Divider(); /*2*/

            final index = i ~/ 2; /*3*/
            if (index >= _suggestions.length) {
                _suggestions.addAll(generateWordPairs().take(10)); /*4*/
            }
            return Text(_suggestions[index].asPascalCase);
        },
    );
}
```

这样应该就会出现一个无限滚动的listview了

更改一下：构建一个listTile

```dart
return ListTile(
    title: Text(
    _suggestions[index].asPascalCase,
    style: _biggerFont,
    ),
);
```

##  给每一个listtile添加事件和icon

```dart
// 这是添加一个icon 
trailing: Icon(
    // NEW from here ...
    alreadySaved ? Icons.favorite : Icons.favorite_border,
    color: alreadySaved ? Colors.red : null,
    semanticLabel: alreadySaved ? 'Remove from saved' : 'Save',
),
//添加事件 当tap的时候 就会执行一个setState()的方法 这个方法会传入一个匿名函数 里面就可以做一些事情
onTap: () {
    setState(() {
        if (alreadySaved) {
            _saved.remove(_suggestions[index]);
        } else {
            _saved.add(_suggestions[index]);
        }
    });
},
```

可以看到 trailing是放在listtile右边的插槽

我们对这个listtile添加一个onTap 就可以给每一个listTile添加事件。

## 导航到新页面

删掉myApp里的一些内容，并且将其改成这样

```dart
Widget build(BuildContext context) {
    return const MaterialApp(
        title: 'startup name generator',
        home: RandomWords(),
    );
}
```

改造RandomWordsState 返回一个Scaffold

```dart
Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Startup Name Generator'),
        actions: [
          IconButton(
            icon: const Icon(Icons.list),
            onPressed: _pushSaved,
            tooltip: 'Saved Suggestions',
          ),
        ],
      ),
      body: ListView.builder(
        itemBuilder: /*1*/ (context, i) {
            final index = i ~/ 2; /*3*/
            var alreadySaved = false;
            if (_suggestions.isNotEmpty && index < _suggestions.length) {
              alreadySaved = _saved.contains(_suggestions[index]); // NEW
            }
            if (i.isOdd) return const Divider(); /*2*/
            if (index >= _suggestions.length) {
              _suggestions.addAll(generateWordPairs().take(10)); /*4*/
            }
            return ListTile(
              //list tile 拥有一个标题 这里设置为一个text
              title: Text(
                _suggestions[index].asPascalCase,
                style: _biggerFont,
              ),
              // 这是添加一个icon
              trailing: Icon(
                // NEW from here ...
                alreadySaved ? Icons.favorite : Icons.favorite_border,
                color: alreadySaved ? Colors.red : null,
                semanticLabel: alreadySaved ? 'Remove from saved' : 'Save',
              ),
              //添加事件 当tap的时候 就会执行一个setState()的方法 这个方法会传入一个匿名函数 里面就可以做一些事情
              onTap: () {
                setState(() {
                  if (alreadySaved) {
                    _saved.remove(_suggestions[index]);
                  } else {
                    _saved.add(_suggestions[index]);
                  }
                });
              },
            );
            ;
          },
      ));
  }
```

我们对RandomWordsState 添加一个私有的跳转方法

```dart
void _pushSaved() {
    Navigator.of(context).push();
}
```

添加逻辑

```dart
void _pushSaved() {
    Navigator.of(context).push(
      MaterialPageRoute<void>(
        builder: (context) {
          final tiles = _saved.map(
            (pair) {
              return ListTile(
                title: Text(
                  pair.asPascalCase,
                  style: _biggerFont,
                ),
              );
            },
          );
          final divided = tiles.isNotEmpty
              ? ListTile.divideTiles(
                  context: context,
                  tiles: tiles,
                ).toList()
              : <Widget>[];

          return Scaffold(
            appBar: AppBar(
              title: const Text('Saved Suggestions'),
            ),
            body: ListView(children: divided),
          );
        },
      ), // ...to here.
    );
  }
```

可以看到 会返回一个Scaffold 并且拥有appBar 和body

这样就可以在点进去之后，跳转到一个页面中了~

## 更改样式和主题

```dart
theme: ThemeData(
          // Add the 5 lines from here...
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.orange,
          foregroundColor: Colors.green,
      )),
```

在myapp里加上themeData



## flutter 布局

flutter一般最外层需要一个Scaffold来包裹

如果没有这个元素 则需要设置内部文字的对齐方式

```dart
return Center(
    child: Container(
        width: 300,
        height: 300,
        decoration: BoxDecoration(
            color: Colors.blue,
            border: Border.all(
                color: Colors.black,
                width: 2,
            ),
        ),
        child: const Text('这都是些啥啊 啊啊啊啊',
                          style: TextStyle(
                              fontSize: 20,
                              color: Colors.black,
                          ),
                          textDirection: TextDirection.ltr),
    ),
);
```

Container 还有很多其他设置

```dart
width: 300,
height: 300,
decoration: BoxDecoration(
    color: Colors.blue,
    border: Border.all(
        color: Colors.black,
        width: 2,
    ),
),
padding:const EdgeInsets.all(10), // 内边距
alignment: Alignment.center, // 内容居中
child: const Text('这都是些啥啊 啊啊啊啊',
                  style: TextStyle(
                      fontSize: 20,
                      color: Colors.black,
                  ),
                  textDirection: TextDirection.ltr),
```

### 文本组件属性

```dart
const Text('dsghaughoihgoishgoiahgoiahgoia',
            style: TextStyle(
              fontSize: 20,
              // color: Colors.black,
              color: Colors.black,
              fontFamily: 'Roboto',
              fontWeight: FontWeight.w500,
              fontStyle: FontStyle.italic,
              decoration: TextDecoration.underline
            ),
            textDirection: TextDirection.ltr,
            textAlign: TextAlign.center,
            overflow: TextOverflow.ellipsis),
```

### 图片

```dart
child: Image.network(
              "https://storage.googleapis.com/cms-storage-bucket/740d82517a6f13db51bd.png",
              fit: BoxFit.cover)), 
```

配置本地资源路径

首先需要新建好路径文件夹

![image-20220711164007026](学习笔记.assets/image-20220711164007026.png)

放入图片后在pubspec配置文件下配置路径

```yml
  # To add assets to your application, add an assets section, like this:
  assets:
   - assets/images/touxiang.jpg
```

```dart
child: Image.asset(
              "../assets/images/touxiang.jpg",
              fit: BoxFit.fitHeight)), 
```

asset引用

### 模板使用

在flutter中我们必须在app组件中含有MaterialAppy以及一个Scaffold

所以我们可以新建一个类，这个类写我们的布局，而其他的东西保持在MyApp中不变，

```dart
class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Flutter Demo'),
        ),
        body: HomeContent(),//这里就是放组件的位置
      ),
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
    );
  }
}
```

组件：

```dart
class HomeContent extends StatelessWidget {
  List list = [];
  HomeContent({super.key}) {
    for (int i = 0; i < 100; i++) {
      list.add("我是第$i条数据");
    }
  }
  @override
  Widget build(BuildContext context) {
    return Center(
        child: ListView.builder(
      itemCount: list.length,
      itemBuilder: (context, index) {
        return ListTile(
          leading: const Icon(Icons.android),
          title: Text(list[index]),
          subtitle: Text("我是子标题$index"),
          trailing: const Icon(Icons.arrow_right_rounded),
        );
      },
      padding: const EdgeInsets.all(10),
    ));
  }
}
```

### flex布局

这里我们对flex进行布局

如果需要子元素是可伸缩的 ，那么只需要指定他为Expanded

```dart
child: Flex(direction: Axis.horizontal, children: <Widget>[
    //固定大小的子元素
    Container(
        width: 100,
        height: 100,
        color: Colors.red,
    ),
    // 可伸缩的子元素
    Expanded(
        flex: 1,
        child: Container(
            height: 100,
            width: 100,
            color: Colors.green,
        ),
    )
]),
```

flex 的分布

```dart
mainAxisAlignment: MainAxisAlignment.center,
```

flex 的alignitems

```dart
crossAxisAlignment: CrossAxisAlignment.center,
```

### 快捷的Flex Row和Column

只需要吧Flex缓存Row或者Column 那么组件就会自动指定主轴，不需要我们指定了

```dart
Column(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    crossAxisAlignment: CrossAxisAlignment.center,
    children: <Widget>[
        //固定大小的子元素
        Container(
            width: 100,
            height: 400,
            color: Colors.red,
        ),
        Container(
            width: 200,
            height: 100,
            color: Colors.blue,
        ),
    ]),
```

### 定位和堆叠

```dart
child: Stack(
    children: [
        Container(
            height: 200,
            width: 200,
            color: Colors.red,
        ),
        Container(
            height: 180,
            width: 180,
            color: Colors.blue,
        ),
        Container(
            height: 160,
            width: 160,
            color: Colors.yellow,
        ),
    ],
)));
```

这里可以看到建了三个container ，而且他们都堆在了一起

通过Positioned组件可以给他的子元素进行定位

```dart
Positioned(
                  left: 150,
                  child: Container(
                    width: 300,
                    height: 300,
                    color: Colors.red,
                  ),
                ),
```

### 底部导航栏

```dart
import 'package:flutter/material.dart';

/// 案例1：简单的无限列表示例
void main(List<String> args) {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Tabs(),
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
    );
  }
}

class Tabs extends StatefulWidget {
  const Tabs({Key? key}) : super(key: key);
  @override
  State<StatefulWidget> createState() {
    return _TabsState();
  }
}

class _TabsState extends State<Tabs> {
  List<Widget> list = [HomePage(), MyPage(), AboutPage()];
  int _currentIndex = 0;
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Scaffold(
      appBar: AppBar(
        title: const Text('这是导航栏'),
      ),
      body: list[_currentIndex],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (int index) {
          setState(() {
            _currentIndex = index;
          });
        },
        fixedColor: Colors.blue,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: '首页',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.list),
            label: '列表',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.info),
            label: '关于',
          ),
        ],
      ),
    );
  }
}

class HomePage extends StatelessWidget {
  const HomePage({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Container(
      alignment: Alignment.center,
      color: Colors.red,
      child: const Text('这是首页'),
    );
  }
}

class MyPage extends StatelessWidget {
  const MyPage({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Container(
      alignment: Alignment.center,
      color: Colors.blueGrey,
      child: const Text('这是我的页面'),
    );
  }
}

class AboutPage extends StatelessWidget {
  const AboutPage({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Container(
      alignment: Alignment.center,
      color: Colors.green,
      child: const Text('关于我'),
    );
  }
}
```

### 路由传参

通过构造函数，可以进行路由的传参：

```dart
final String title;
const MySearchPage({Key? key, required this.title}) : super(key: key);

homepage
    
ElevatedButton(
    child: const Text('跳转到第二页'),
    onPressed: () {
        Navigator.of(context).push(
            MaterialPageRoute(
                builder: (context) {
                    return MySearchPage(title: '这是搜索');
                }, //括号里可以传参
            ),
        );
    },
),
```

同时可以在pushNamed的时候携带argument，这个需要通过Modal等东西去获取到数据。

```dart
ModalRoute.of(context)?.settings.arguments
```

### 表单

使用textFild可以设置表单

```dart
TextField(
    decoration:
    InputDecoration(hintText: '输入用户名', icon: Icon(Icons.people)),
)
```

```dart
TextField(
    decoration:
    InputDecoration(hintText: '输入用户名', icon: Icon(Icons.people)),
    onChanged: (value) {
        setState(() {
            _msg = value;
        });
    },
),
```

### 状态管理方案

使用自带的provider

```dart
ChangeNotifierProvider<UserInfo>.value(
      value: UserInfo("我是adk", "nickname", 12);
      child: MyApp(),
  )
```

通过ChangeNotifierProvider 可以给指定的子组件传入对于的值

```dart
home: Scaffold(
    appBar: AppBar(
        title: Text('你好'),
    ),
    body: Text("你的用户名是${Provider.of<UserInfo>(context).username}"),
),
```

这样去接受provider的值

### 路由管理方案 fluro

```dart
void main(List<String> args) {
    FluroRouter router = FluroRouter();
    Routes.configureRoutes(router);
    Application.router = router;
    runApp(MyApp());
}

class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return MaterialApp(
            title: '我的app2',
            onGenerateRoute: Application.router.generator,
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: MyHomePage(title: 'Flutter Demo Home Page'),
        );
    }
}

class Application {
    static FluroRouter router = FluroRouter();
}

class Routes {
    static void configureRoutes(FluroRouter router) {
        router.define('/',
                      handler: Handler(
                          handlerFunc: (context, params) =>
                          MyHomePage(title: 'Flutter Demo Home Page'),
                      ));
        router.define("/sb",
                      handler: Handler(
                          handlerFunc: (context, params) => MyHomePage(title: 'this sb page'),
                      ));
        router.notFoundHandler = Handler(
            handlerFunc: (context, params) => PageEmpty(),
        );
    }
}
```

我们可以依赖一些第三方的包来做到route的路由管理，这里需要注意要使用2.0版本以上的包，并且写法发生了改变，需要使用**static FluroRouter router = FluroRouter()**

在routes里面去定义相应的路由就可以使用router了。

## 项目

### 项目搭建

首先项目的结构需要整理 大概是这样的通用结构：

![image-20220714131636849](学习笔记.assets/image-20220714131636849.png)

### 使用适配插件 Screen_utils

首先安装：

```yml
dev_dependencies:
  flutter_test:
    sdk: flutter
  provider: ^6.0.0
  fluro: ^2.0.0
  flutter_lints: ^2.0.0
  flutter_screenutil: ^5.0.0
```

可以看到这里安装了5.0版本

所以用法是有所不同的：

然后再main里面进行初始化:

```dart
class MyApp extends StatelessWidget {
    const MyApp({Key? key}) : super(key: key);
    // This widget is the root of your application.
    @override
    Widget build(BuildContext context) {
        //填入设计稿中设备的屏幕尺寸,单位dp
        return ScreenUtilInit(
            designSize: const Size(750, 1334),
            minTextAdapt: true,
            splitScreenMode: true,
            builder: (context, child) {
                return MaterialApp(
                    debugShowCheckedModeBanner: false,
                    title: '这是首页',
                    // You can use the library anywhere in the app even in theme
                    theme: ThemeData(
                        primarySwatch: Colors.blue,
                        textTheme: Typography.englishLike2018.apply(fontSizeFactor: 1.sp),
                    ),
                    home: child,
                );
            },
            child: WelcomePage(),
        );
    }
}
```

初始化完成后我们就可以在项目里进行使用了，

5.0版本不需要封装一个utils，我们可以直接这么使用。

```dart
padding: EdgeInsets.all(10.h),
margin: EdgeInsets.all(10.h),
```

### 定义全局常量 静态文件

新建个values的文件夹，新增colors.dart

或者constant也行

并且新增一个contant.dart的文件，将constant文件夹下的包全部统一导出

```dart
library constant;
export 'colors.dart';
```

```dart
class AppColors {
  static const Color primaryText = Color.fromARGB(1, 0, 0, 0);
  static const Color primaryBackground = Color.fromARGB(1, 255, 255, 255);
  static const Color primaryElement = Color.fromARGB(244, 12, 137, 255);
}
```

### 制作页面 组件

dart也有着组件化的概念，每一个页面我们可以分为页内组件和页外组件，如果不需要交互的组件，可以封装成私有函数来进行使用 就像这样

![image-20220714145737711](学习笔记.assets/image-20220714145737711.png)

如上可以看到，我们一个页面没分为了几个不同的组件，并且可以互相调用



### 布局的高度以及宽度问题

在ROW和Column中是不支持溢出移动出现滚动条之类的特性的，而且对于其内的children来说，如果溢出了则会报溢出bug，并不是自适应

解决这个问题，可以使用expand组件，又或者给row或Column包一层IntrinsicHeight

这两个方法都可以解决children元素溢出的问题

**在row中的文本不能自动换行，就可以利用Expanded来包裹进行解决**

#### Spacer()

spacer常用布局中

实际上是一个简写：

SizedBox 的flex1的简写 ，所以他会自动占用剩下的空间

### 按钮样式设置

对于按钮的设置，需要一个特殊的方式进行设置:

```dart
child: ElevatedButton(
    onPressed: () {},
    child: Text('Start'),
    style: ElevatedButton.styleFrom(
        primary: AppColors.primaryElement,
        textStyle:
        TextStyle(fontSize: 26.sp, fontWeight: FontWeight.w600)),
));
```

可以看到，**ElevatedButton.styleFrom**是关键属性，设置内部的样式则需要textStyle等

### 路由

路由在全局下新建一个路由

```dart
import 'package:flutter_movie/pages/sign/sign_up.dart';
import 'package:flutter_movie/pages/welcomepage/welcome.dart';

var staticRoutes = {
  "/": (context) => WelcomePage(),
  "/sign-up": (context) => SignUpPage(),
};
```

```dart
return MaterialApp(
    debugShowCheckedModeBanner: false,
    routes: staticRoutes,
    initialRoute: "/",
    title: '这是首页',
    // You can use the library anywhere in the app even in theme
    theme: ThemeData(
        primarySwatch: Colors.blue,
        textTheme: Typography.englishLike2018.apply(fontSizeFactor: 1.sp),
    ),
    // home: child,
);
```

这样就能够将路由设置好了。

### 封装input组件

对于一些组件 可以进行抽取并封装，将其统一放在WidGets的目录下：

```dart
Widget InputTextField({
  required TextEditingController controller,
  TextInputType keyboardType = TextInputType.text,
  String hintText = "请输入内容",
  bool isPassword = false,
  double marginTop = 0,
}) {
  return Container(
    height: 44.h,
    margin: EdgeInsets.only(top: marginTop),
    padding: EdgeInsets.symmetric(horizontal: 5.w),
    decoration: BoxDecoration(
      color: AppColors.secondaryBackground,
      borderRadius: AppRadius.br10px,
    ),
    child: TextField(
      controller: controller,
      keyboardType: keyboardType,
      decoration: InputDecoration(
        border: InputBorder.none,
        hintText: hintText,
        contentPadding: EdgeInsets.fromLTRB(10, 10, 0, 9),
        hintStyle: TextStyle(
            color: AppColors.secondaryText,
            fontSize: 20.sp,
            fontWeight: FontWeight.w600,
            fontFamily: 'MediumFont'),
      ),
      style: TextStyle(
        color: AppColors.secondaryText,
        fontSize: 18.sp,
        fontWeight: FontWeight.w600,
      ),
      maxLines: 1,
      autocorrect: false,
      obscureText: isPassword,
    ),
  );
}
```

这样就可以使用函数的方式去调用组件了

这样去调用:

```dart
InputTextField(
    controller: _EmailController,
    hintText: 'Email',
    keyboardType: TextInputType.emailAddress,
    marginTop: 0),
InputTextField(
    controller: _PasswordController,
    hintText: 'Password',
    isPassword: true,
    marginTop: 20.h,
),
```

这里的controller 需要去final定义

```dart
final _PasswordController = TextEditingController();

final _EmailController = TextEditingController();
```



### 封装button

同上 对button进行组件的创建 并进行封装：

```dart
Widget MyTextbutton({
  required VoidCallback voidCallback,
  double width = double.infinity,
  double height = 44.0,
  Color btnColor = AppColors.primaryElement,
  String text = 'btn',
  Color fontColor = AppColors.primaryElementText,
  String fontName = 'MediumFont',
  FontWeight fontWeight = FontWeight.w600,
}) {
  return Container(
    width: width,
    height: height,
    child: ElevatedButton(
      onPressed: voidCallback,
      style: ElevatedButton.styleFrom(
        primary: btnColor,
        shape: RoundedRectangleBorder(
          borderRadius: AppRadius.br5px,
        ),
      ),
      child: Text(
        text,
        textAlign: TextAlign.center,
        style: TextStyle(
            fontFamily: fontName,
            color: fontColor,
            fontSize: 20.sp,
            fontWeight: FontWeight.w600,
            height: 1),
      ),
    ),
  );
}
```

这里需要给按钮做一个表单验证的工具函数:

```dart
/// 检测输入的字符串是否为email
bool isEmail(String input) {
  if (input == null || input.isEmpty) {
    return false;
  }
  String regexEmail = r'^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$';
  return RegExp(regexEmail).hasMatch(input);
}

/// 检查输入字符串的长度
bool checkInputLength(String input, int min, int max) {
  if (input == null || input.isEmpty) {
    return false;
  }
  if (input.length < min || input.length > max) {
    return false;
  }
  return true;
}
```

然后去编写button的事件函数,其中我们需要toast组件来进行信息的提示

这里用到了flutter_toast的库进行提示

```dart

```

